<!DOCTYPE html>
<html>
<head>
	<title>My JavaScript Project</title>
	
   <link rel="stylesheet" type="text/css" href="./CSS/index.css">
	<script src="https://components.connect.trimble.com/trimble-connect-workspace-api/index.js"></script>
   <script src="./ModelsJs/Project.js"></script>
   <script src="./ModelsJs/API_Rests/PsetsRequests.js"></script>
   <script src="./Helpers/RequestHelper.js"></script>
	
	<script src="https://unpkg.com/xdomain@0.8.2/dist/xdomain.min.js"></script>
</head>
<body>

   <h2 class="Title2-center">Arkance Extension</h2>

   <hr>
   
   <div style="text-align: center; margin: 5px;">
      <button id="btnCreate">Create folders</button>
   </div>

<!-- <script src="https://jonathang89.github.io/TrimbleConnectTest/script.js"/> -->
<script type="module">
   xdomain.slaves({
    "https://pset-api.connect.trimble.com": "/v1/proxy.html",
    "https://org-api.connect.trimble.com": "/v1/proxy.html"
  });
   //  console.log("Test log");

      const psetBaseString = 'https://pset-api.connect.trimble.com/v1/';
      const orgBaseString = "https://org-api.connect.trimble.com/v1/";
      const appBaseString = "https://app21.connect.trimble.com/tc/api/2.0/";
      const modelApiBaseString = "https://model-api21.connect.trimble.com/";

      console.log("Api:");

      const API = await TrimbleConnectWorkspace.connect(window.parent, (event, data) => {
        console.log("Event: ", event, data);
      });

      const responseProject = await API.project.getProject();
      console.log("Response Project: ", responseProject); // Trimble Connect project details
      const projectId = responseProject.id;

      const responseAccessToken = await API.extension.requestPermission("accesstoken");
      console.log("responseAccessToken: ", responseAccessToken);
      const accessToken = responseAccessToken;
    	
      var headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${accessToken}`
         }

      const projectForestString = orgBaseString.concat(`forests/project:${projectId}:data/trees/ProjectContext/nodes/PSetLibs`);

      const projectForestTreesString = orgBaseString.concat(`forests/project:${projectId}:data/trees`);

      const appProjectInfoProject = appBaseString.concat(`projects/${projectId}`);

      const responseProjectInfo =  await fetch(appProjectInfoProject, {
         method: 'GET',
         headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${accessToken}`
         }
      });

      let projectInfo = await responseProjectInfo.json();
      var rootId = projectInfo.rootId;
      
      console.log("baseFolderId: ", rootId);

      const responseModels = await API.viewer.getModels();

      console.log("models: ", responseModels);

      const model = responseModels[2];

      console.log("endApi:")

   //  getData();

   //  async function getData() 
   //  {
   //    console.log("debut test: ");

   //    const responseModel = await API.viewer.getModels();
   //    const model = responseModel[2];
      
   //    console.log("response model: ", responseModel);
   //    console.log("modelId: ", model.id);

   //    // document.getElementById('test').innerHTML = model.name;

   //    //#region Get Forest

   //    const responseForest = await fetch(projectForestString, {
   //      method: 'GET',
   //      headers: {
   //          'Content-Type': 'application/json',
   //          'Authorization': `Bearer ${accessToken}`
   //      }
   //   });
     
   //   const responseForestJson = await responseForest.json();
     
   //   console.log("response Forest json: ", responseForestJson);
     
   //   //#endregion
     
   //   // Get Library Id
   //   const libId = responseForestJson.links[0].substring(8);
   //   console.log("libId: ", libId);

   //   //#region Forest Trees
     
   //   const responseForestTrees = await fetch(projectForestTreesString, {
   //      method: 'GET',
   //      headers: {
   //         'Content-Type': 'application/json',
   //         'Authorization': `Bearer ${accessToken}`
   //       }
   //    });
      
   //    const responseForestTreesJson = await responseForestTrees.json();
 
   //    console.log("responseForestTreesJson: ", responseForestTreesJson);
      
   //    //#endregion Forest Trees

   //   //#region Project Context Nodes
   //   const projectForestProjectContextString = projectForestTreesString.concat("/ProjectContext/nodes");
     
   //   const responseProjectContext = await fetch(projectForestProjectContextString, {
   //      method: 'GET',
   //      headers: {
   //         'Content-Type': 'application/json',
   //         'Authorization': `Bearer ${accessToken}`
   //       }
   //    });
      
   //    var ProjectContextJson = await responseProjectContext.json();
      
   //    console.log("ProjectContextNodes:", ProjectContextJson);
   //    //#endregion      

   //    //Create Library string for request
   //    const getLibString = `${psetBaseString}libs/${libId}`;

   //    //Create LibraryDefinition string for request
   //   const getLibDefsString = `${getLibString}/defs`;

   //   //#region Get Library
   //   const responseLib = await fetch(getLibString, {
   //      method: 'GET',
   //      headers: {
   //          'Content-Type': 'application/json',
   //          'Authorization': `Bearer ${accessToken}`
   //      }
   //   });

   //   console.log("get library:", await responseLib.json());
   //   //#endregion

   //   //#region Get Library Def
   //   const responseLibDefs = await fetch(getLibDefsString, {
   //      method: 'GET',
   //      headers: {
   //          'Content-Type': 'application/json',
   //          'Authorization': `Bearer ${accessToken}`
   //      }
   //   });

   //   const LibDefs = await responseLibDefs.json();

   //   console.log("library definitions: ", LibDefs);

   //   //#endregion

   //   // Display first library definition
   //   const firstLibDef = LibDefs.items[0];

   //   console.log("get first library def:", firstLibDef);

   //   const defId = firstLibDef.id;

   //   //#region Get model Entities
   //   // Create request to get model entities
   //    const modelInfoString = modelApiBaseString.concat(`models/${model.id}/entities`);
      
   //    const responseModelInfo =  await fetch(modelInfoString, {
   //       method: 'GET',
   //       headers: {
   //          'Content-Type': 'application/json',
   //          'Authorization': `Bearer ${accessToken}`
   //       }
   //    });

   //    let modelInfos = await responseModelInfo.json();

   //    let modelEntities = modelInfos.items;

   //    // console.log("modelEntities: ", modelEntities);
      
   //    //#endregion

   //    //#region PsetRequest test
   //    // Create frn link for first entity
   //    let entityFrnTest = `frn:entity:${modelEntities[0].id}`;

   //    let psetForEntityTestString = psetBaseString.concat(`psets/${entityFrnTest}`);

   //    let responseEntityPsetTest = await fetch(psetForEntityTestString, {
   //       method: 'GET',
   //       headers: {
   //          'Content-Type': 'application/json',
   //          'Authorization': `Bearer ${accessToken}`
   //       }
   //    });

   //    console.log("test PsetsRequests: ", await responseEntityPsetTest.json());
   //    //#endregion

   //    let entities = new Array();

   //    console.log("num: ", modelEntities.length);

   //    var entityId = modelEntities[655].id;

      

   //    // console.log("entity infos: ", entityInfo);

   // //    for (let index = 0; index < modelEntities.length; index++) {
   // //       let entityId = modelEntities[index].id
   // //       let entityFrn = `frn:entity:${entityId}`;

   // //       let psetForEntityString = psetBaseString.concat(`psets/${entityFrn}`);

   // //       const getEntityPsetByDefIdString = psetForEntityString.concat(`/${libId}/${defId}`);

   // //       if (index < 500){

   // //          var responseEntityPsetByDefIdPatch = await fetch(getEntityPsetByDefIdString, {
   // //             method: 'PATCH',
   // //             body: JSON.stringify({
   // //                "props": 
   // //                {
   // //                   "prop_fn1lmx6z7qwngdy1g7qubrlvmub416h3": "A1"
   // //                }
   // //             }),
   // //             headers: {
   // //                'Content-Type': 'application/json',
   // //                'Authorization': `Bearer ${accessToken}`
   // //             },
   // //          });
   // //       }else{
   // //           responseEntityPsetByDefIdPatch = await fetch(getEntityPsetByDefIdString, {
   // //             method: 'PATCH',
   // //             body: JSON.stringify({
   // //                "props": 
   // //                {
   // //                   "prop_fn1lmx6z7qwngdy1g7qubrlvmub416h3": "A2"
   // //                }
                  
   // //             }),
   // //             headers: {
   // //                'Content-Type': 'application/json',
   // //                'Authorization': `Bearer ${accessToken}`
   // //             },
   // //          });
   // //       }

   // //   let entityPsetPatch = await responseEntityPsetByDefIdPatch.json();

   // //   console.log("patched entity pSet: ", entityPsetPatch);

   // //   entities.push(entityPsetPatch);

   // //   console.log("entity added: ", entityPsetPatch);

   // //   console.log("psetValue: ", entityPsetPatch.props);

   // //   if (!psetsValues.includes(entityPsetPatch.props))
   // //   {
   // //    psetsValues.push(entityPsetPatch.props);
   // //   }

   // // };

   //    // console.log("entities", entities);

   //   var projectInstance = new ProjectClass(responseProject.id, responseProject.name);

   //   console.log("projectInstance: ", projectInstance);


   //   console.log("responseCreateFolder:", appBaseString.concat("folders"));

   // //   for (let index = 0; index < psetsValues.length; index++) {
   // //    let value = psetsValues[index];
   // // };

   // }
   
   document.getElementById("btnCreate").onclick = function() { createFolderHierarchy() };

   async function createFolderHierarchy()
    {
      const responseModel = await API.viewer.getModels();
      const model = responseModel[2];

      var params = "include=id,idx,psets,psets.name";

      // var modelContext = {};

      const modelInfoString = modelApiBaseString.concat(`models/${model.id}/entities`);

      const responseModelInfo =  await fetch(modelInfoString, {
         method: 'GET',
         headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${accessToken}`
         }
      });

      let modelInfos = await responseModelInfo.json();

      let modelEntities = modelInfos.items;

      console.log("modelEntities: ", modelEntities);

      const responseProjectInfo =  await fetch(appProjectInfoProject, {
         method: 'GET',
         headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${accessToken}`
         }
      });

      console.log("creating folder:");
      
      // const appBaseFolderString = appBaseString.concat(`folders/${rootId}/items`);
      
      // const responseFolderInfo =  await fetch(appBaseFolderString, {
      //    method: 'GET',
      //    headers: {
      //       'Content-Type': 'application/json',
      //       'Authorization': `Bearer ${accessToken}`
      //    }
      // });

      let rootFolderItems = GetFolderItems(rootId);

      console.log("root folder items:", rootFolderItems);
      
      // console.log("root folder items: ", await rootFolderItems.json());
      
      var targetedFolder;
      
      rootFolderItems.forEach(folder => {
         if (folder.name == "ListeProperties"){
            targetedFolder = folder
         }
      });
      
      console.log("targetedFolder: ", targetedFolder);
      
      console.log("model enitty: ", modelEntities[0]);

      var entityInfoString = modelInfoString.concat(`/${modelEntities[0].id}`);

      console.log("entity info string: ", entityInfoString);

      // console.log("entityinfosstring:",entityInfoString);
      // console.log("headers:",headers);
      // console.log("params:",params);

      // var entityInfo = await GetRequest(entityInfoString, headers, params);

      const responseEntityIbfo = await fetch(entityInfoString + '?' + new URLSearchParams(params), {
        method: 'GET',
        headers: {
           'Content-Type': 'application/json',
           'Authorization': `Bearer ${accessToken}`
         }
      });

      const entityInfoJson = await responseEntityIbfo.json();

      console.log("entity infos json: ", entityInfoJson);

      var psetsArray = new Array();
      
      psetsArray = entityInfoJson.psets;

      console.log("psetsArray: ", psetsArray);

      var pset;

      psetsArray.forEach(object => {
         if (object.name == 'Project_Identification') {
            pset = object;
         }
      });

      console.log("pset: ", pset);

      var stringToSplit = `${pset.values[0]}`;

      console.log("stringToSplit: ", stringToSplit);

      var splitedString = new Array();

      splitedString = stringToSplit.split('-');

      console.log("splitedString: ", splitedString);

      var targetedFolderId = targetedFolder.id;

         splitedString.forEach(string => {
         //    if (responseCreation.errorcode == "DUPLICATE_NAME" && responseCreation)
         //    {
               responseCreation = createFolder(string, targetedFolderId, accessToken);
               console.log("response creation folder: ", responseCreation)
               // if (responseCreation.success)
            // }
         })

      let responseCreation = await responseCreateFolder.json();

      console.log("responseFolderCreation: ", responseCreation);
    }

    async function createFolder(name, parentId, acccessToken)
    {
      var responseCreateFolder = await fetch(appBaseString.concat("folders"), {
               method:"POST",
               body: JSON.stringify({
                  "name":`${name}`,
                  "parentId":`${parentId}`
               }),
               headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${accessToken}`
               }
            });
         var responseCreation = await responseCreateFolder.json();
         return responseCreation;
    }
 
    async function GetFolderItems(folderId)
    {
      const responseFolderInfo =  await fetch(appBaseString.concat(`folders/${folderId}/items`), {
         method: 'GET',
         headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${accessToken}`
         }
      });

      const result = await responseFolderInfo.json();

      return result;
    }
 
 </script>
</body>
</html>
